---
// Hero section with FitzHugh-Nagumo neuron model visualization
---

<section class="relative min-h-[480px] md:min-h-[560px] flex items-center overflow-hidden bg-gradient-primary">
	<!-- Animated background -->
	<div class="absolute inset-0">
		<canvas id="fitzhugh-nagumo" class="w-full h-full opacity-60"></canvas>
	</div>
	
	<!-- Content -->
	<div class="container mx-auto px-4 py-20 relative z-10">
		<div class="max-w-4xl mx-auto text-center text-white">
			<!-- Main title -->
			<h1 
				class="text-4xl md:text-5xl lg:text-6xl font-display font-bold mb-6 animate-fade-in"
				style="animation-delay: 0.1s"
			>
				Sistemas Din치micos
				<span class="block mt-2 text-transparent bg-clip-text bg-gradient-to-r from-white via-unam-gold-300 to-white animate-gradient-shift" style="background-size: 200% 200%;">
					No Lineales
				</span>
			</h1>
			
			<!-- Subtitle -->
			<p 
				class="text-xl md:text-2xl mb-8 text-white/90 animate-fade-in"
				style="animation-delay: 0.3s"
			>
				Investigaci칩n interdisciplinaria en modelado matem치tico y an치lisis de sistemas complejos
			</p>
			
			<!-- Scroll indicator -->
			<div 
				class="mt-16 animate-bounce"
				style="animation-delay: 0.5s"
			>
				<svg class="w-6 h-6 mx-auto text-white/70" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
				</svg>
			</div>
		</div>
	</div>
</section>

<script>
	// FitzHugh-Nagumo neuron model visualization
	const canvas = document.getElementById('fitzhugh-nagumo') as HTMLCanvasElement;
	if (canvas) {
		const ctx = canvas.getContext('2d');
		if (ctx) {
			// Set canvas size
			const resizeCanvas = () => {
				canvas.width = canvas.offsetWidth;
				canvas.height = canvas.offsetHeight;
			};
			resizeCanvas();
			window.addEventListener('resize', resizeCanvas);
			
			// FitzHugh-Nagumo parameters
			const a = 0.7;
			const b = 0.8;
			const tau = 12.5;
			const I = 0.5; // External current
			const dt = 0.1;
			
			// Initial conditions
			let v = -1;
			let w = -0.5;
			
			// History for phase space and time series
			const phasePoints: {x: number, y: number}[] = [];
			const timePoints: {t: number, v: number}[] = [];
			const maxPhasePoints = 500;
			const maxTimePoints = 200;
			let time = 0;
			
			// Animation loop
			const animate = () => {
				// FitzHugh-Nagumo equations
				const dv = (v - (v * v * v) / 3 - w + I) * dt;
				const dw = ((v + a - b * w) / tau) * dt;
				
				v += dv;
				w += dw;
				time += dt;
				
				// Store points
				const canvasWidth = canvas.width;
				const canvasHeight = canvas.height;
				
				// Phase space (left side)
				const phaseScale = 80;
				const phaseCenterX = canvasWidth * 0.25;
				const phaseCenterY = canvasHeight / 2;
				const px = phaseCenterX + v * phaseScale;
				const py = phaseCenterY - w * phaseScale;
				
				phasePoints.push({x: px, y: py});
				if (phasePoints.length > maxPhasePoints) {
					phasePoints.shift();
				}
				
				// Time series (right side)
				const timeScale = 2;
				const voltageScale = 60;
				const timeCenterX = canvasWidth * 0.65;
				const timeCenterY = canvasHeight / 2;
				const tx = timeCenterX + (timePoints.length * timeScale);
				const ty = timeCenterY - v * voltageScale;
				
				timePoints.push({t: tx, v: ty});
				if (timePoints.length > maxTimePoints) {
					timePoints.shift();
				}
				
				// Clear canvas with fade effect
				ctx.fillStyle = 'rgba(0, 61, 130, 0.05)';
				ctx.fillRect(0, 0, canvasWidth, canvasHeight);
				
				// Draw phase space trajectory (left)
				if (phasePoints.length > 1) {
					ctx.beginPath();
					ctx.moveTo(phasePoints[0].x, phasePoints[0].y);
					
					for (let i = 1; i < phasePoints.length; i++) {
						ctx.lineTo(phasePoints[i].x, phasePoints[i].y);
					}
					
					ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
					ctx.lineWidth = 1.5;
					ctx.stroke();
					
					// Draw current point
					const lastPoint = phasePoints[phasePoints.length - 1];
					ctx.beginPath();
					ctx.arc(lastPoint.x, lastPoint.y, 4, 0, Math.PI * 2);
					ctx.fillStyle = 'rgba(197, 165, 114, 1)'; // UNAM gold
					ctx.fill();
				}
				
				// Draw time series (right)
				if (timePoints.length > 1) {
					ctx.beginPath();
					ctx.moveTo(timePoints[0].t, timePoints[0].v);
					
					for (let i = 1; i < timePoints.length; i++) {
						ctx.lineTo(timePoints[i].t, timePoints[i].v);
					}
					
					ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
					ctx.lineWidth = 1.5;
					ctx.stroke();
				}
				
				// Draw labels
				ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
				ctx.font = '14px Arial';
				ctx.fillText('Espacio de Estados (v, w)', canvasWidth * 0.05, 30);
				ctx.fillText('Voltaje (v)', canvasWidth * 0.55, 30);
				
				requestAnimationFrame(animate);
			};
			
			animate();
		}
	}
</script>
